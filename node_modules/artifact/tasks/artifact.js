var AG = require('../lib/artifact'),
    fs = require('fs.extra'),
    path = require('path'),
    beautify = require('js-beautify').js_beautify,
    _ = require('lodash'),
    tar = require('tar-fs'),
    repo = require('../lib/repos/agService'),
    zlib = require('zlib'),
    ncp = require('ncp').ncp,
    Q = require('q'),
    semver = require('semver');

module.exports = function(grunt) {

    var config = {
        distDir: './dist',
        clean: false
    };

    var gruntConfig = grunt.config('dist');
    if (gruntConfig) {
        config = _.extend(config, gruntConfig);
    }

    var prepareDistDirectory = function(dir) {
        if (config.clean === 'true' || config.clean === true || config.clean === undefined) {
            fs.removeSync(dir);
        }
        if (!fs.existsSync(dir)) {
            fs.mkdirpSync(dir);
        }
    };

    grunt.registerTask('dist', distTask);


    function distTask() {
        var dir = path.normalize(process.cwd() + path.sep + config.distDir),
            done = this.async(),
            pkg;

        if (this.args[0] === 'prepare') {
            pkg = _.clone(grunt.pkg ? grunt.pkg : require(process.cwd() + path.sep + 'package.json'));

            prepareDistDirectory(dir);

            copyNodeModules(pkg).then(function() {
                copyPackageJson(pkg, grunt.config('dist.package.omit'), false, done);
            }).
            catch (function(e) {
                console.log(e);
            });
        } else if (this.args[0] === 'publish') {

            try {
                AG.cmds.publish(createArtifactJson(dir), null, dir).then(function() {
                    done();
                }).
                catch (function(error) {
                    grunt.fail.fatal(error);
                    done();
                });
            } catch (error) {
                grunt.fail.fatal(error);
                done();
            }
        } else {
            done();
        }
    }

    function createArtifactJson(dir) {
        var pkg = require(dir + path.sep + 'package.json');

        var artifact = _.extend({
            name: pkg.name,
            version: pkg.version,
            description: pkg.description || ''
        }, grunt.config('dist.artifact'));


        if (!artifact.repository && pkg.repository) {
            artifact.repository = pkg.repository;
        }

        if (!artifact.keywords && pkg.keywords) {
            artifact.keywords = pkg.keywords;
        }
        return artifact;
    }

    function copyPackageJson(pkg, omit, release, done) {
        var pattern = /build\.([0-9]*)/;

        pkg.version = pkg.version.split('-')[0];

        function latestVersionWithSamePatch() {
            var lowerBound = ">=" + pkg.version + '-build.1';
            var uppperBound = "<" + semver.inc(pkg.version, 'patch') + '-build.1';
            return lowerBound + ' ' + uppperBound;
        }

        if (!release) {
            AG.cmds.resolve({
                name: pkg.name,
                version: latestVersionWithSamePatch()
            }).then(function(latest) {
                if (latest.version === pkg.version) {
                    grunt.fail.fatal('Version ' + pkg.version + ' of ' + pkg.name + ' is already released.');
                } else {
                    var matches = pattern.exec(latest.version);
                    if (matches && matches.length) {
                        pkg.version += '-build.' + (1 + parseInt(matches[1], 10));
                    } else {
                        pkg.version += '-build.1';
                    }
                }
            }, function() {
                pkg.version += '-build.1';
            }).
            finally(function() {
                writePackageJson(pkg, omit);
                done();
            });
        } else {
            writePackageJson(pkg, omit);
            done();
        }
    }

    function copyNodeModules(pkg) {
        var deferred = Q.defer();

        if (pkg.dependencies) {
            var promises = [];

            fs.mkdirpSync(config.distDir + path.sep + 'node_modules');

            Object.keys(pkg.dependencies).forEach(function(name) {
                var module = path.sep + 'node_modules' + path.sep + name;
                promises.push(Q.nfcall(ncp, process.cwd() + module, config.distDir + module));
            });

            return Q.all(promises);
        }

        deferred.resolve();

        return deferred.promise;
    }

    function writePackageJson(pkg, omit) {
        var cleanedPkg = _.omit(pkg, omit);
        fs.writeFileSync(config.distDir + path.sep + 'package.json', beautify(JSON.stringify(cleanedPkg)));
    }

};
